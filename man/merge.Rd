% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/merge.R
\name{merge}
\alias{merge}
\title{Merge two data frames}
\usage{
merge(
  x,
  y,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  all = FALSE,
  all.x = all,
  all.y = all,
  sort = TRUE,
  suffixes = c(".x", ".y"),
  no.dups = TRUE,
  allow.cartesian = getOption("datatable.allow.cartesian"),
  ...
)
}
\arguments{
\item{x, y}{\code{data table}s. \code{y} is coerced to a \code{data.table} if
it isn't one already.}

\item{by}{A vector of shared column names in \code{x} and \code{y} to merge on.
This defaults to the shared key columns between the two tables.
If \code{y} has no key columns, this defaults to the key of \code{x}.}

\item{by.x, by.y}{Vectors of column names in \code{x} and \code{y} to merge on.}

\item{all}{logical; \code{all = TRUE} is shorthand to save setting both
\code{all.x = TRUE} and \code{all.y = TRUE}.}

\item{all.x}{logical; if \code{TRUE}, then extra rows will be added to the
output, one for each row in \code{x} that has no matching row in \code{y}.
These rows will have 'NA's in those columns that are usually filled with values
from \code{y}.  The default is \code{FALSE}, so that only rows with data from both
\code{x} and \code{y} are included in the output.}

\item{all.y}{logical; analogous to \code{all.x} above.}

\item{sort}{logical. If \code{TRUE} (default), the merged \code{data.table} is
sorted by setting the key to the \code{by / by.x} columns. If \code{FALSE}, the
result is not sorted.}

\item{suffixes}{A \code{character(2)} specifying the suffixes to be used for
making non-\code{by} column names unique. The suffix behaviour works in a similar
fashion as the \code{\link{merge.data.frame}} method does.}

\item{no.dups}{logical indicating that \code{suffixes} are also appended to
non-\code{by.y} column names in \code{y} when they have the same column name
as any \code{by.x}.}

\item{allow.cartesian}{See \code{allow.cartesian} in \code{\link[data.table]{[.data.table}}.}

\item{...}{
  Arguments passed on to \code{\link[=joyn]{joyn}}
  \describe{
    \item{\code{match_type}}{character: one of \emph{"m:m"}, \emph{"m:1"}, \emph{"1:m"}, \emph{"1:1"}.
Default is \emph{"m:m"} since this is the default generally used in joins in R.
However, following Stata's recommendation, it is better to be explicit and
use any of the other three match types (See details in \emph{match types
sections}).}
    \item{\code{keep}}{character: One of \emph{"full"}, \emph{"left"}, \emph{"master"}, \emph{"right"},
\emph{"using"}, \emph{"inner"}. Default is \emph{"full"}. Even though this is not the
regular behavior of joins in R, the objective of \code{joyn} is to present a
diagnosis of the join, so that it must use by default a full join. Yet, if
\emph{"left"} or \emph{"master"}, it keeps the observations that matched in both
tables and the ones that did not match in x. The ones in y will be
discarded. If \emph{"right"} or \emph{"using"}, it keeps the observations that
matched in both tables and the ones that did not match in y. The ones in x
will be discarded. If \emph{"inner"}, it only keeps the observations that
matched both tables.}
    \item{\code{roll}}{double: \emph{to be implemented}}
    \item{\code{y_vars_to_keep}}{character: Vector of variable names that will be kept after the
merge. If TRUE (the default), it keeps all the brings all the variables in
y into x. If FALSE or NULL, it does not bring any variable into x, but a
report will be generated.}
    \item{\code{reportvar}}{character: Name of reporting variable. Default if "report".
This is the same as variable "_merge" in Stata after performing a merge. If
FALSE or NULL, the reporting variable will be excluded from the final
table, though a summary of the join will be display after concluding.}
    \item{\code{reporttype}}{character: One of \emph{"character"} or \emph{"numeric"}. Default is
\emph{"character"}. If \emph{"numeric"}, the reporting variable will contain  numeric
codes of the source and the contents of each observation in the joined
table.}
    \item{\code{update_NAs}}{logical: If TRUE, it will update NA values of all variables
in x with actual values of variables in y that have the same name as the
ones in x. If FALSE, NA values won't be updated, even if \code{update_values} is
\code{TRUE}}
    \item{\code{update_values}}{logical: If TRUE, it will update all values of variables
in x with the actual of variables in y with the same name as the ones in x.
\strong{NAs from y won't be used to update actual values in x}. Yet, by default,
NAs in x will be updated with values in y. To avoid this, make sure to set
\code{update_NAs = FALSE}}
    \item{\code{verbose}}{logical: if FALSE, it won't display any message (programmer's
option). Default is TRUE.}
    \item{\code{keep_common_vars}}{logical: If TRUE, it will keep the original variable from
y when both tables have common variable names. Thus, the prefix "y." will
be added to the original name to distinguish from the resulting variable in
the joined table.}
  }}
}
\description{
This is a joyn wrapper that works in a similar fashion to \link[base:merge]{base::merge} and
\link[data.table:merge]{data.table::merge}, which is why \link{merge} masks the other two.
}
